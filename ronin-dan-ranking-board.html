<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rōnin Dan Ranking Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000000; /* Black background from new theme */
            color: #e0e0e0; /* Off-white text */
            text-shadow: 1px 1px #000000;
        }
        /* Apply font to inputs and buttons */
        input, button, label {
             font-family: 'Press Start 2P', cursive;
        }
        .dan-rank {
            border-left: 4px solid;
        }
        /* New Dan Colors from Ronin PNG Palette */
        .dan-1, .dan-2, .dan-3 { border-color: #facc15; } /* Vibrant Yellow */
        .dan-4, .dan-5, .dan-6, .dan-7 { border-color: #f43f5e; } /* Vibrant Pink/Rose */
        .dan-8, .dan-9, .dan-10 { border-color: #4f46e5; } /* Vibrant Blue/Indigo */

        .points-positive { color: #22d3ee; } /* Cyan */
        .points-negative { color: #f43f5e; } /* Pink/Rose */
        .points-neutral { color: #6b7280; } /* Gray */

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn {
            border-style: solid;
            border-width: 2px;
            border-top-color: #ffffff50;
            border-left-color: #ffffff50;
            border-bottom-color: #00000050;
            border-right-color: #00000050;
        }
        .btn:active {
            border-top-color: #00000050;
            border-left-color: #00000050;
            border-bottom-color: #ffffff50;
            border-right-color: #ffffff50;
            transform: translateY(1px);
        }
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        /* Animation class for player rows */
        .player-row {
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.3s ease;
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">
    <canvas id="confetti-canvas"></canvas>
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
             <svg viewBox="0 0 400 100" xmlns="http://www.w3.org/2000/svg" class="h-48 mx-auto" aria-label="Rōnin">
                <defs>
                    <linearGradient id="titleGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#facc15;" /> <!-- Vibrant Yellow -->
                        <stop offset="100%" style="stop-color:#f43f5e;" /> <!-- Vibrant Pink/Rose -->
                    </linearGradient>
                </defs>
                <!-- Shadow/Outline -->
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#4f46e5" font-family="'Press Start 2P', cursive" font-size="80" style="transform: translate(5px, 5px);">
                    Rōnin
                </text>
                 <!-- Main Text -->
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="url(#titleGradient)" font-family="'Press Start 2P', cursive" font-size="80">
                    Rōnin
                </text>
            </svg>
            <p class="text-xs text-gray-400 mt-4 leading-relaxed">A lightweight portable dan ranking board to track player progress and rankings in your local scene.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Add Player/Character Form -->
            <div class="bg-gray-900 p-6 border-2 border-rose-500">
                <h2 class="text-xl font-semibold text-rose-500 mb-4">Add Player / Character</h2>
                <form id="add-form" class="flex flex-col gap-4">
                    <div>
                        <label for="gamer-tag" class="block text-xs font-medium text-gray-300 mb-2">Gamer Tag</label>
                        <input type="text" id="gamer-tag" required class="mt-1 block w-full bg-black border-2 border-gray-700 py-2 px-3 text-white text-xs focus:outline-none focus:ring-2 focus:ring-rose-500 focus:border-rose-500">
                    </div>
                    <div>
                        <label for="character-name" class="block text-xs font-medium text-gray-300 mb-2">Character</label>
                        <input type="text" id="character-name" required class="mt-1 block w-full bg-black border-2 border-gray-700 py-2 px-3 text-white text-xs focus:outline-none focus:ring-2 focus:ring-rose-500 focus:border-rose-500">
                    </div>
                    <div>
                        <button type="submit" class="w-full bg-rose-600 hover:bg-rose-700 text-white py-2 px-4 transition duration-200 text-xs btn">Add Entry</button>
                    </div>
                </form>
                 <p class="text-[10px] text-gray-500 mt-3">New entries start at 10 Dan. If Gamer Tag exists, new character is added.</p>
            </div>

            <!-- Import/Export Section -->
            <div class="bg-gray-900 p-6 flex flex-col gap-6 justify-center border-2 border-indigo-600">
                <div>
                    <h3 class="text-base font-semibold text-indigo-400 mb-2">Export Data</h3>
                    <p class="text-[10px] text-gray-400 mb-3">Save the current ranking board to a .csv file.</p>
                    <button id="export-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 transition duration-200 text-xs btn">Export CSV</button>
                </div>
                <div>
                    <h3 class="text-base font-semibold text-yellow-400 mb-2">Import Data</h3>
                    <p class="text-[10px] text-gray-400 mb-3">This will overwrite current data.</p>
                    <input type="file" id="import-file" class="hidden" accept=".csv">
                    <button id="import-button" class="w-full bg-yellow-500 hover:bg-yellow-600 text-black py-2 px-4 transition duration-200 text-xs btn">Import CSV</button>
                </div>
            </div>
        </div>


        <!-- Ranking Board -->
        <main id="ranking-board" class="space-y-6">
            <!-- Ranks will be dynamically inserted here -->
        </main>

        <footer class="text-center mt-12 mb-4">
            <p class="text-xs text-gray-500">
                Vibe-coded by <a href="https://www.aaroncalzado.com" target="_blank" rel="noopener noreferrer" class="text-rose-500 hover:underline">Aaron Calzado</a> via <a href="https://gemini.google.com/" target="_blank" rel="noopener noreferrer" class="text-rose-500 hover:underline">Google Gemini</a>
            </p>
        </footer>
    </div>

    <script>
        const gamerTagInput = document.getElementById('gamer-tag');
        const characterNameInput = document.getElementById('character-name');
        const addForm = document.getElementById('add-form');
        const rankingBoard = document.getElementById('ranking-board');
        const exportButton = document.getElementById('export-button');
        const importButton = document.getElementById('import-button');
        const importFileInput = document.getElementById('import-file');

        let players = JSON.parse(localStorage.getItem('danRankingPlayers')) || [];

        // --- ANIMATION & RENDERING ---

        // A wrapper function to handle animations during updates
        async function updateAndAnimateBoard() {
            const firstPositions = new Map();
            // First, get the initial positions of all player rows
            document.querySelectorAll('.player-row').forEach(el => {
                firstPositions.set(el.id, el.getBoundingClientRect());
            });

            // Re-render the board with the new data
            renderBoard();

            // Allow the DOM to update but wait for the next frame before animating
            // This is key to making the FLIP technique work
            await new Promise(resolve => requestAnimationFrame(resolve));

            // Last, Invert, Play
            document.querySelectorAll('.player-row').forEach(el => {
                const lastPos = el.getBoundingClientRect();
                const firstPos = firstPositions.get(el.id);

                if (firstPos) { // This row existed before the render
                    const deltaX = firstPos.left - lastPos.left;
                    const deltaY = firstPos.top - lastPos.top;

                    // If the element moved, invert its position then play the animation
                    if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5) {
                        el.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        el.style.transition = 'transform 0s'; // No transition on the inversion

                        // In the next frame, remove the transform to animate it back to its new position
                        requestAnimationFrame(() => {
                            el.style.removeProperty('transform');
                            el.style.removeProperty('transition');
                        });
                    }
                } else { // This is a new row, animate its appearance
                    el.style.opacity = '0';
                    el.style.transform = 'scale(0.95)';
                    requestAnimationFrame(() => {
                        el.style.opacity = '1';
                        el.style.transform = 'scale(1)';
                    });
                }
            });
        }


        // Main function to render the entire board
        function renderBoard() {
            rankingBoard.innerHTML = ''; // Clear the board before rendering

            if (players.length === 0) {
                rankingBoard.innerHTML = `
                    <div class="text-center py-10 bg-gray-900 border-2 border-gray-700">
                        <h3 class="text-lg text-white">No Players Yet</h3>
                        <p class="text-xs text-gray-400 mt-2">Add a player using the form above to get started!</p>
                    </div>
                `;
                return;
            }

            const ranks = {};
            for (let i = 1; i <= 10; i++) {
                ranks[i] = [];
            }
            players.forEach(player => {
                player.characters.forEach(character => {
                    if (ranks[character.dan]) {
                        ranks[character.dan].push({ ...character, playerName: player.name, playerId: player.id });
                    }
                });
            });

            for (let dan = 1; dan <= 10; dan++) {
                const charactersInRank = ranks[dan];

                charactersInRank.sort((a, b) => {
                    if (b.points !== a.points) {
                        return b.points - a.points;
                    }
                    return (a.sortOrder || 0) - (b.sortOrder || 0);
                });

                const section = document.createElement('section');
                section.className = `dan-rank dan-${dan} bg-gray-900 p-4 sm:p-6`;

                let headerText = `${dan} Dan`;
                if (dan === 1) headerText += " (Highest)";
                if (dan === 10) headerText += " (Lowest)";

                let characterListHTML = '<div class="text-center text-gray-500 italic py-4 text-xs">No characters at this rank.</div>';

                if (charactersInRank.length > 0) {
                    characterListHTML = charactersInRank.map((char, i, arr) => {
                        const canMoveUp = i > 0 && arr[i-1].points === char.points;
                        const canMoveDown = i < arr.length - 1 && arr[i+1].points === char.points;
                        // Create a stable, unique ID for each player row for animation tracking
                        const characterId = `char-${char.playerId}-${char.name.replace(/[^a-zA-Z0-9]/g, '-')}`;

                        return `
                        <div id="${characterId}" class="player-row flex items-center justify-between bg-black p-3 mb-2 flex-wrap border-2 border-gray-800">
                            <!-- Player and Character Info -->
                            <div class="flex-grow mb-2 sm:mb-0 mr-4">
                                <p class="font-bold text-sm text-white">${char.playerName}</p>
                                <p class="text-xs text-gray-300 mt-1">${char.name}</p>
                            </div>

                            <!-- Points Display -->
                            <div class="flex items-center mx-4 my-2 sm:my-0">
                                <span class="text-xs mr-2 text-gray-400">Points:</span>
                                <span class="font-mono text-xl ${getPointsClass(char.points)}">${formatPoints(char.points)}</span>
                            </div>

                            <!-- Action Buttons -->
                            <div class="flex items-center space-x-2">
                                <button onclick="moveCharacter('${char.playerId}', '${char.name}', 'up')" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-8 h-8 transition duration-200 flex items-center justify-center text-xs btn" ${!canMoveUp ? 'disabled' : ''}>&uarr;</button>
                                <button onclick="moveCharacter('${char.playerId}', '${char.name}', 'down')" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-8 h-8 transition duration-200 flex items-center justify-center text-xs btn" ${!canMoveDown ? 'disabled' : ''}>&darr;</button>
                                <button onclick="updatePoints('${char.playerId}', '${char.name}', 1)" class="bg-teal-500 hover:bg-teal-600 text-white font-bold w-10 h-10 text-base transition duration-200 btn">+</button>
                                <button onclick="updatePoints('${char.playerId}', '${char.name}', -1)" class="bg-rose-600 hover:bg-rose-700 text-white font-bold w-10 h-10 text-base transition duration-200 btn">-</button>
                                <button onclick="deleteCharacter('${char.playerId}', '${char.name}')" class="bg-gray-800 hover:bg-gray-700 text-white font-bold w-10 h-10 text-[10px] transition duration-200 btn">Del</button>
                            </div>
                        </div>
                    `}).join('');
                }

                section.innerHTML = `
                    <h2 class="text-xl font-bold text-white mb-4">${headerText}</h2>
                    <div class="space-y-2">
                        ${characterListHTML}
                    </div>
                `;
                rankingBoard.appendChild(section);
            }
        }

        function getPointsClass(points) {
            if (points > 0) return 'points-positive';
            if (points < 0) return 'points-negative';
            return 'points-neutral';
        }

        function formatPoints(points) {
            return points > 0 ? `+${points}` : `${points}`;
        }

        function savePlayers() {
            localStorage.setItem('danRankingPlayers', JSON.stringify(players));
        }

        addForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const gamerTag = gamerTagInput.value.trim();
            const characterName = characterNameInput.value.trim();
            if (!gamerTag || !characterName) return;

            let player = players.find(p => p.name.toLowerCase() === gamerTag.toLowerCase());

            if (player) {
                const charExists = player.characters.some(c => c.name.toLowerCase() === characterName.toLowerCase());
                if (charExists) {
                    alert('This character already exists for this player.');
                    return;
                }
                player.characters.push({ name: characterName, dan: 10, points: 0, sortOrder: Date.now() });
            } else {
                player = {
                    id: crypto.randomUUID(),
                    name: gamerTag,
                    characters: [{ name: characterName, dan: 10, points: 0, sortOrder: Date.now() }]
                };
                players.push(player);
            }

            savePlayers();
            updateAndAnimateBoard();
            addForm.reset();
        });

        window.updatePoints = function(playerId, characterName, amount) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const character = player.characters.find(c => c.name === characterName);
            if (!character) return;

            character.points += amount;

            if (character.points >= 3) {
                if (character.dan > 1) {
                    character.dan -= 1;
                    character.points = 0;
                    triggerConfetti();
                } else {
                    character.points = 2;
                }
            }

            if (character.points <= -3) {
                if (character.dan < 10) {
                    character.dan += 1;
                    character.points = 0;
                } else {
                    character.points = -2;
                }
            }

            savePlayers();
            updateAndAnimateBoard();
        }

        window.moveCharacter = function(playerId, characterName, direction) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const sourceChar = player.characters.find(c => c.name === characterName);
            if (!sourceChar) return;

            const charactersInRank = players.flatMap(p =>
                p.characters.map(char => ({...char, playerId: p.id}))
            ).filter(char => char.dan === sourceChar.dan);

            charactersInRank.sort((a, b) => b.points - a.points || a.sortOrder - b.sortOrder);

            const sourceIndex = charactersInRank.findIndex(c => c.playerId === playerId && c.name === characterName);
            if (sourceIndex === -1) return;

            const targetIndex = direction === 'up' ? sourceIndex - 1 : sourceIndex + 1;
            if (targetIndex < 0 || targetIndex >= charactersInRank.length) return;

            const targetCharData = charactersInRank[targetIndex];
            if (sourceChar.points !== targetCharData.points) {
                console.error("Cannot move character with different points.");
                return;
            }

            const targetPlayer = players.find(p => p.id === targetCharData.playerId);
            const targetChar = targetPlayer.characters.find(c => c.name === targetCharData.name);

            [sourceChar.sortOrder, targetChar.sortOrder] = [targetChar.sortOrder, sourceChar.sortOrder];

            savePlayers();
            updateAndAnimateBoard();
        }

        window.deleteCharacter = function(playerId, characterName) {
            if (!confirm(`Are you sure you want to delete ${characterName} for this player?`)) {
                return;
            }
            const playerIndex = players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            const player = players[playerIndex];
            player.characters = player.characters.filter(c => c.name !== characterName);

            if (player.characters.length === 0) {
                players.splice(playerIndex, 1);
            }

            savePlayers();
            updateAndAnimateBoard();
        }

        // --- IMPORT/EXPORT FUNCTIONS ---
        function exportData() {
            if (players.length === 0) {
                alert("There is no data to export.");
                return;
            }
            const header = ['playerId', 'playerName', 'characterName', 'dan', 'points', 'sortOrder'];
            const rows = players.flatMap(player =>
                player.characters.map(character => [
                    player.id, player.name, character.name, character.dan,
                    character.points, character.sortOrder || Date.now()
                ])
            );
            let csvContent = "data:text/csv;charset=utf-8," + header.join(",") + "\n" + rows.map(e => e.join(",")).join("\n");
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `ronin_dan_ranking_data.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (!confirm("Are you sure you want to import this file? This will overwrite all current data.")) {
                importFileInput.value = ""; return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const lines = e.target.result.trim().split('\n');
                    const header = lines.shift().trim().split(',');
                    const sortOrderIndex = header.indexOf('sortOrder');
                    if (header.indexOf('playerId') === -1) throw new Error("Invalid CSV format.");

                    const importedPlayersMap = new Map();
                    lines.forEach(line => {
                        if (!line) return;
                        const values = line.trim().split(',');
                        const [playerId, playerName, characterName, dan, points] = values;
                        const sortOrder = sortOrderIndex !== -1 ? (parseInt(values[sortOrderIndex], 10) || Date.now()) : Date.now();
                        if (!importedPlayersMap.has(playerId)) {
                            importedPlayersMap.set(playerId, { id: playerId, name: playerName, characters: [] });
                        }
                        importedPlayersMap.get(playerId).characters.push({ name: characterName, dan: parseInt(dan), points: parseInt(points), sortOrder });
                    });
                    players = Array.from(importedPlayersMap.values());
                    savePlayers();
                    updateAndAnimateBoard();
                    alert("Data imported successfully!");
                } catch (error) {
                    console.error("Error parsing CSV:", error);
                    alert("Failed to import CSV.");
                } finally {
                    importFileInput.value = "";
                }
            };
            reader.readAsText(file);
        }

        exportButton.addEventListener('click', exportData);
        importButton.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importData);

        // --- CONFETTI EFFECT ---
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiPieces = [];
        const confettiColors = ['#facc15', '#f43f5e', '#4f46e5', '#22d3ee'];
        function resizeCanvas() { confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; }
        function triggerConfetti() {
            confettiPieces = [];
            for (let i = 0; i < 150; i++) confettiPieces.push(createConfettiPiece());
        }
        function createConfettiPiece() {
            const w = Math.random() * 8 + 4;
            const h = Math.random() * 4 + 3;
            return {
                x: Math.random() * confettiCanvas.width, y: -20, w, h,
                color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
                vx: (Math.random() - 0.5) * 4, vy: Math.random() * 2 + 2,
                angle: Math.random() * Math.PI * 2, spin: (Math.random() - 0.5) * 0.2
            };
        }
        function drawConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            confettiPieces.forEach(p => {
                p.y += p.vy; p.x += p.vx; p.angle += p.spin;
                confettiCtx.save();
                confettiCtx.translate(p.x, p.y);
                confettiCtx.rotate(p.angle);
                confettiCtx.fillStyle = p.color;
                confettiCtx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
                confettiCtx.restore();
            });
            confettiPieces = confettiPieces.filter(p => p.y < confettiCanvas.height + 20);
        }
        function animateConfetti() {
            if (confettiPieces.length > 0) drawConfetti();
            requestAnimationFrame(animateConfetti);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animateConfetti();

        // Initial render on page load
        updateAndAnimateBoard();
    </script>
</body>
</html>
